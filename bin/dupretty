#!/usr/bin/perl
#eval 'exec perl -S $0 $*'
#if 0;


#-----------------------------------------------------------------------
# Main program
#-----------------------------------------------------------------------
use strict 'vars';
use Getopt::Long;

#-----------------------------------------------------------------------
# Variables available to subroutines
#-----------------------------------------------------------------------
local $::DEBUG;
local $::ID = '$Id$';
local *DU;

#-----------------------------------------------------------------------
# Top level variables
#-----------------------------------------------------------------------
my $options;
my $files;
my $pgm = $0;
my @args = @ARGV;

#-----------------------------------------------------------------------
# Process the command line arguments
#-----------------------------------------------------------------------
(
    $::DEBUG,
    $options,
    $files
) = &parseArgs;

#-----------------------------------------------------------------------
# Open the necessary files
#-----------------------------------------------------------------------
&openDU($options, $files);

#-----------------------------------------------------------------------
# Print the header for the report file before processing so things
# found during processing can be written to the report file
#-----------------------------------------------------------------------
&processDU();

close(OUT);

exit(0);


#*******************************************************************************
# defaults()
# =>
#
# This procedure returns a pointer to a hash containing global default values
#
#*******************************************************************************
sub defaults {

    unless(defined $main::DEFAULTS_SET) {

        $main::DEFAULTS_SET = 1;
        $main::DEFAULTS     = {} unless(defined $main::DEFAULTS);

        my %defaults =
            (
                debug        => 0,
                indent       => 6,
                options      => "-shc"
            );

        #---------------------------------------------------------------
        # Load into the global defaults if not already defined
        #---------------------------------------------------------------
        my $key;
        foreach $key (keys %defaults) {
            if(!defined $main::DEFAULTS->{$key}) {
                $main::DEFAULTS->{$key} = $defaults{$key};
            }
        }
    }

    return($main::DEFAULTS);

} # sub defaults


#*****************************************************************************
# printVersion($exitCode)
# =>
#
# exitCode: Exit code to return to the calling shell
#
# Print the version information for this program.
#
#*****************************************************************************
sub printVersion {
    my($exitCode) = @_;

    #-------------------------------------------------------------------
    # Exit with version information
    #-------------------------------------------------------------------
    $! = $exitCode;
    die <<EOF;

Version information for: $0

       $::ID

EOF
} # sub printVersion


#*****************************************************************************
# usage()
# =>
#
# Print the usage information for this program.  If an argument is passed to
# this procedure it is printed too (before usage information).
#
#*****************************************************************************
sub usage {
    my($exitCode, $msg) = @_;

    #-------------------------------------------------------------------
    # Print any message passed to the routine as the first argument
    # in the argument list
    #-------------------------------------------------------------------
    print(STDERR "ERROR: $msg\n\n") if $msg;

    #-------------------------------------------------------------------
    # Grab the defaults for reporting
    #-------------------------------------------------------------------
    my $options = &defaults()->{options};

    #-------------------------------------------------------------------
    # Exit with usage information
    #-------------------------------------------------------------------
    $! = $exitCode;
    die <<EOF;
Usage: $0 [-info] [-help] [-Version] [-options 'du options'] <filenames>

       $::ID

Read a DEF file and summarize the different tokens found in requested nets
within the SPECIALNETS section.

Switches
--------
    -options        options to pass to 'du'
                        [DEFAULT = \"$options\"]
    -help           This information!
    -Version        Print version information

NOTE: The options may be shortened to be the smallest unique match:

    Can use     To match
    -------     --------
    -h          -help
    -o          -options
    -V          -Version

EOF

} # sub usage


#*****************************************************************************
# parseArgs()
# => Option settings
#
# Take the command line inputs and return the options to use
#
#*****************************************************************************
sub parseArgs {

    #-------------------------------------------------------------------
    # Declare variables to hold the result of the getopts() call
    #-------------------------------------------------------------------
    my $debug;
    my $options;
    my $version;
    my $files;
    my $help;

    #-------------------------------------------------------------------
    # Use the neat long 'getopts' stuff
    #-------------------------------------------------------------------
    &usage(1) unless(
        &GetOptions(
            'debug:i'    => \$debug,
            'options=s'  => \$options,
            'help'       => \$help,
            'Version'    => \$version
        )
    );

    &usage(2)        if($help);
    &printVersion(3) if($version);

    #-------------------------------------------------------------------
    # Define which files / dirs to work on
    #-------------------------------------------------------------------
    if($#ARGV == -1) {
        $files = "*";
    } else {
        $files = shift;
    }

    #-------------------------------------------------------------------
    # Return a list of settings to the main program
    #-------------------------------------------------------------------
    return(
        ($debug     or &defaults()->{debug}),
        ($options   or &defaults()->{options}),
        $files
    );

} # parseArgs


#*******************************************************************************
# openDU(options, files)
# =>
#
# options: Options to be used by 'du'
# files:   Files to process
#
# Run 'du' and re-format the output
#
#*******************************************************************************
sub openDU {
    my($options, $files) = @_;

    unless(open(DU, "du $options $files |")) {
        $! = 3;
        die("Can't open pipe to 'du': $@")
    }

} # sub openDU


#*****************************************************************************
# commas($_)
# => comma printed integer
#
# _: Use the default working line to hold the integer to be processed
#
# Given an integer return with commas to make the output more readable.
#
#*****************************************************************************
sub commas {
    local($_) = @_;

    1 while s/(.*\d)(\d\d\d)/$1,$2/;
    $_;
} # sub commas


#*******************************************************************************
# processDU()
# =>
#
# Process 'du' output
#
#*******************************************************************************
sub processDU {

    my($Line);
    my($size, $fileDir);
    my $fmtSize;

    while ($Line = <DU>) {
        ($size, $fileDir) = split(/\s+/, $Line);

        $fmtSize = &formatSize($size);

        printf("%s %s\n", $fmtSize, $fileDir);
    }

} # sub processDU


#*******************************************************************************
# formatSize($size)
# =>
#
# size:        Size of file / dir to format
#
# Return the size shifted based on the size
#
#*******************************************************************************
sub formatSize {
    my($size) = @_;

    my($value);
    my($mult);
    my($rSize);
    my($posn);
    my($outSize);
    my($indent) = &defaults()->{indent};
    my($dots)   = substr("    ." x 50, 0, $indent);

    #-------------------------------------------------------------------
    # Get time stamp information
    #-------------------------------------------------------------------
    ($value, $mult) = $size =~ /([\d.]+)(.)/;

    $rSize = sprintf("%${indent}s", $value);

    if     ($mult eq 'K') {
        $posn = 2;
    } elsif($mult eq 'M') {
        $posn = 1;
    } elsif($mult eq 'G') {
        $posn = 0;
    }

    $outSize =
        sprintf(
            "%s%s%s%s",
            " " x ($posn * $indent),
            $rSize,
            $mult,
            $dots x (2 - $posn)
        );

    return($outSize);

} # sub formatSize
